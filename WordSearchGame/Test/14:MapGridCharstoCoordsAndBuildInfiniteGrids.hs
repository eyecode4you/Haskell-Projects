-- output grid
og :: Show a => [a] -> IO ()
og = putStrLn . unlines . map show

coords = [ [(0,0), (0,1), (0,2), (0,3), (0,4), (0,5), (0,6), (0,7)]
         , [(1,0), (1,1), (1,2), (1,3), (1,4), (1,5), (1,6), (1,7)]
         , [(2,0), (2,1), (2,2), (2,3), (2,4), (2,5), (2,6), (2,7)]
         , [(3,0), (3,1), (3,2), (3,3), (3,4), (3,5), (3,6), (3,7)]
         , [(4,0), (4,1), (4,2), (4,3), (4,4), (4,5), (4,6), (4,7)]
         , [(5,0), (5,1), (5,2), (5,3), (5,4), (5,5), (5,6), (5,7)]
         , [(6,0), (6,1), (6,2), (6,3), (6,4), (6,5), (6,6), (6,7)]
         , [(7,0), (7,1), (7,2), (7,3), (7,4), (7,5), (7,6), (7,7)]
         ]

-- First, we want to match each char in grid to ^^^these (x,y) coord values
grid = [ "LMTH________Q__"
       , "___O_______R___"
       , "__C_O_____A____"
       , "__O__B_U_DN____"
       , "__M___ENA_A___O"
       , "__P____R__D___Y"
       , "__T____EEDOCEYE"
       , "__IBM_MA__H___H"
       , "_HASKELL__S____"
       , "________L______"
       ]

-- building infinite coord grid:
cols = repeat [0..]
rows = map repeat [0..]
zipOverGrid = zipWith zip
infiniteCoords = zipOverGrid rows cols

main :: IO ()
main = do
  og $ zipOverGrid coords grid
  {- Is limited to 8x8 grid by structure of coords (zip only process to length of shortest list)
  [((0,0),'L'),((0,1),'M'),((0,2),'T'),((0,3),'H'),((0,4),'_'),((0,5),'_'),((0,6),'_'),((0,7),'_')]
  [((1,0),'_'),((1,1),'_'),((1,2),'_'),((1,3),'O'),((1,4),'_'),((1,5),'_'),((1,6),'_'),((1,7),'_')]
  [((2,0),'_'),((2,1),'_'),((2,2),'C'),((2,3),'_'),((2,4),'O'),((2,5),'_'),((2,6),'_'),((2,7),'_')]
  [((3,0),'_'),((3,1),'_'),((3,2),'O'),((3,3),'_'),((3,4),'_'),((3,5),'B'),((3,6),'_'),((3,7),'U')]
  [((4,0),'_'),((4,1),'_'),((4,2),'M'),((4,3),'_'),((4,4),'_'),((4,5),'_'),((4,6),'E'),((4,7),'N')]
  [((5,0),'_'),((5,1),'_'),((5,2),'P'),((5,3),'_'),((5,4),'_'),((5,5),'_'),((5,6),'_'),((5,7),'R')]
  [((6,0),'_'),((6,1),'_'),((6,2),'T'),((6,3),'_'),((6,4),'_'),((6,5),'_'),((6,6),'_'),((6,7),'E')]
  [((7,0),'_'),((7,1),'_'),((7,2),'I'),((7,3),'B'),((7,4),'M'),((7,5),'_'),((7,6),'M'),((7,7),'A')]
  -}

  og $ zipOverGrid infiniteCoords grid
  {- we now have the full 10x15 grid
  [((0,0),'L'),((0,1),'M'),((0,2),'T'),((0,3),'H'),((0,4),'_'),((0,5),'_'),((0,6),'_'),((0,7),'_'),((0,8),'_'),((0,9),'_'),((0,10),'_'),((0,11),'_'),((0,12),'Q'),((0,13),'_'),((0,14),'_')]
  [((1,0),'_'),((1,1),'_'),((1,2),'_'),((1,3),'O'),((1,4),'_'),((1,5),'_'),((1,6),'_'),((1,7),'_'),((1,8),'_'),((1,9),'_'),((1,10),'_'),((1,11),'R'),((1,12),'_'),((1,13),'_'),((1,14),'_')]
  [((2,0),'_'),((2,1),'_'),((2,2),'C'),((2,3),'_'),((2,4),'O'),((2,5),'_'),((2,6),'_'),((2,7),'_'),((2,8),'_'),((2,9),'_'),((2,10),'A'),((2,11),'_'),((2,12),'_'),((2,13),'_'),((2,14),'_')]
  [((3,0),'_'),((3,1),'_'),((3,2),'O'),((3,3),'_'),((3,4),'_'),((3,5),'B'),((3,6),'_'),((3,7),'U'),((3,8),'_'),((3,9),'D'),((3,10),'N'),((3,11),'_'),((3,12),'_'),((3,13),'_'),((3,14),'_')]
  [((4,0),'_'),((4,1),'_'),((4,2),'M'),((4,3),'_'),((4,4),'_'),((4,5),'_'),((4,6),'E'),((4,7),'N'),((4,8),'A'),((4,9),'_'),((4,10),'A'),((4,11),'_'),((4,12),'_'),((4,13),'_'),((4,14),'O')]
  [((5,0),'_'),((5,1),'_'),((5,2),'P'),((5,3),'_'),((5,4),'_'),((5,5),'_'),((5,6),'_'),((5,7),'R'),((5,8),'_'),((5,9),'_'),((5,10),'D'),((5,11),'_'),((5,12),'_'),((5,13),'_'),((5,14),'Y')]
  [((6,0),'_'),((6,1),'_'),((6,2),'T'),((6,3),'_'),((6,4),'_'),((6,5),'_'),((6,6),'_'),((6,7),'E'),((6,8),'E'),((6,9),'D'),((6,10),'O'),((6,11),'C'),((6,12),'E'),((6,13),'Y'),((6,14),'E')]
  [((7,0),'_'),((7,1),'_'),((7,2),'I'),((7,3),'B'),((7,4),'M'),((7,5),'_'),((7,6),'M'),((7,7),'A'),((7,8),'_'),((7,9),'_'),((7,10),'H'),((7,11),'_'),((7,12),'_'),((7,13),'_'),((7,14),'H')]
  [((8,0),'_'),((8,1),'H'),((8,2),'A'),((8,3),'S'),((8,4),'K'),((8,5),'E'),((8,6),'L'),((8,7),'L'),((8,8),'_'),((8,9),'_'),((8,10),'S'),((8,11),'_'),((8,12),'_'),((8,13),'_'),((8,14),'_')]
  [((9,0),'_'),((9,1),'_'),((9,2),'_'),((9,3),'_'),((9,4),'_'),((9,5),'_'),((9,6),'_'),((9,7),'_'),((9,8),'L'),((9,9),'_'),((9,10),'_'),((9,11),'_'),((9,12),'_'),((9,13),'_'),((9,14),'_')]
  -}
